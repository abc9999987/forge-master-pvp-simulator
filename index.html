<!DOCTYPE html>
<html lang='en'>
<head>
  <meta charset='UTF-8' />
  <title>Forge Master PVP ì˜ˆì¸¡</title>

  <style>
    /* ------------------------------
    Minimal + Cute UI Theme
    ------------------------------ */
    body {
        font-family: 'Nunito', 'Pretendard', sans-serif;
        background: #faf7f5;
        color: #333;
        padding: 40px;
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    h1 {
        font-size: 28px;
        font-weight: 800;
        margin-bottom: 20px;
        color: #ff8a7a;
    }

    h3 {
        font-weight: 700;
        margin-top: 0;
        color: #555;
    }

    /* Panel */
    .panel {
        background: white;
        padding: 25px;
        margin-bottom: 25px;
        border-radius: 18px;
        width: 360px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        border: 2px solid #ffe1dc;
    }

    /* Layout */
    .wrap {
        display: flex;
        gap: 40px;
        margin-bottom: 20px;
    }

    /* Label + Input */
    label {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: 8px 0;
        font-size: 14px;
        color: #444;
    }

    input[type='number'] {
        width: 90px;
        padding: 6px 8px;
        border-radius: 10px;
        border: 1.8px solid #ffc5bc;
        background: #fff6f5;
        font-size: 13px;
    }

    /* Button */
    button {
        background: #ff8a7a;
        color: white;
        padding: 12px 26px;
        border-radius: 14px;
        border: none;
        cursor: pointer;
        font-size: 15px;
        font-weight: 700;
        margin-top: 20px;
        box-shadow: 0 3px 8px rgba(0,0,0,0.12);
    }

    button:hover { background: #ff7a68; }

    /* Result */
    #battleResult {
        margin-top: 20px;
        font-size: 18px;
        font-weight: 700;
        color: #ff6b5a;
        text-align: center;
    }

    /* Log table wrapper */
    #logWrapper {
        max-height: 260px;
        overflow-y: auto;
        width: 530px;
        margin-top: 20px;
        background: white;
        border-radius: 14px;
        border: 2px solid #ffd7d1;
        box-shadow: 0 4px 10px rgba(0,0,0,0.07);
    }

    table {
        width: 100%;
        border-collapse: collapse;
        font-size: 13px;
    }

    table th {
        background: #ffe6e2;
        padding: 10px;
        position: sticky;
        top: 0;
        font-weight: 700;
        color: #444;
    }

    table td {
        padding: 8px;
        border-bottom: 1px solid #f5d2cc;
        text-align: center;
        color: #333;
    }

    .highlight {
        background: #fff0ec;
        font-weight: 700;
        color: #ff6b5a;
    }
    /* Skill selectors */
    .skill-panel {
      background: white;
      padding: 16px;
      margin-bottom: 18px;
      border-radius: 14px;
      width: 760px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.06);
      border: 2px solid #ffecec;
    }

    .skill-area {
      display: flex;
      justify-content: space-between;
      gap: 20px;
      align-items: flex-start;
    }

    .skill-column {
      width: 50%;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .skill-select {
      padding: 8px 10px;
      border-radius: 10px;
      border: 1.5px solid #ffd6d0;
      background: #fffaf9;
      font-size: 14px;
    }
    .skill-icon {
      width: 48px;
      height: 48px;
      border-radius: 8px;
      background-image: url('skills.png');
      background-repeat: no-repeat;
      /* default to full sheet (48px width x 864px height) so each slice is 48x48 */
      background-size: 48px 864px;
      background-position: 0px 0px;
      margin-left: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      visibility: hidden;
      flex: 0 0 48px;
    }

    </style>
</head>

<body>

  <h1>Forge Master PVP ì˜ˆì¸¡</h1>

  <div class='wrap'>
    <div class='panel' id='blockA'>
      <h3>ë‚˜</h3>
      <div class='groupA'></div>
    </div>

    <div class='panel' id='blockB'>
      <h3>ì </h3>
      <div class='groupB'></div>
    </div>
  </div>

  <div class='skill-panel' id='skillPanel'>
    <h3 style='margin:0 0 10px 0;'>ìŠ¤í‚¬ ì„ íƒ</h3>
    <div class='skill-area'>
      <div class='skill-column' id='mySkills'>
        <label>ë‚´ ìŠ¤í‚¬</label>
        <!-- 3 left selects inserted by JS -->
      </div>

      <div class='skill-column' id='enemySkills'>
        <label>ì  ìŠ¤í‚¬</label>
        <!-- 3 right selects inserted by JS -->
      </div>
    </div>
  </div>

  <button onclick='startBattle()'>ì „íˆ¬ ì‹œì‘!</button>

  <p style='margin-top: 12px; font-size: 14px; color: #666; text-align: center;'>
    ì „íˆ¬ëŠ” ìµœëŒ€ 60ì´ˆ ë™ì•ˆ ì§„í–‰ë˜ë©°, ë¨¼ì € ìƒëŒ€ë¥¼ ì“°ëŸ¬ëœ¨ë¦¬ê±°ë‚˜ ì‹œê°„ì´ ì¢…ë£Œë˜ì—ˆì„ ë•Œ ì²´ë ¥ì´ ë” ë§ì´ ë‚¨ì€ ìª½ì´ ìŠ¹ë¦¬í•©ë‹ˆë‹¤.
  </p>

  <h2 id='battleResult'></h2>
  
  <div id='logWrapper'>
    <table id='logTable'>
        <thead>
        <tr>
            <th>ì „íˆ¬ ì‹œê°„ (sec)</th>
            <th>ë‚˜</th>
            <th>ì </th>
        </tr>
        </thead>
        <tbody></tbody>
    </table>
  </div>

<script>
/* -----------------------------------------------------------
   UI Generator: automatically creates stat inputs
----------------------------------------------------------- */
const STAT_FIELDS = [
  ['power', 'ì´ í”¼í•´'],
  ['hitrate', 'ê¸°ë³¸ ê³µê²© ì†ë„'],
  ['speedbuff', 'ê³µê²© ì†ë„(%)'],
  ['doubleproc', 'ë”ë¸” ì°¬ìŠ¤(%)'],
  ['critproc', 'ì¹˜ëª…íƒ€ í™•ë¥ (%)'],
  ['critbonus', 'ì¹˜ëª…íƒ€ í”¼í•´(%)'],
  ['drain', 'ìƒëª…ë ¥ í¡ìˆ˜(%)'],
  ['regen', 'ì²´ë ¥ ì¬ìƒ(%)'],
  ['guard', 'ë¸”ë¡ í™•ë¥ (%)'],
  ['vital', 'ì´ ì²´ë ¥'],
  ['hpmult', 'PVP ì²´ë ¥ ë³´ì •(%)'],
  ['startup', 'ê·¼ì ‘ ë”œë ˆì´(ì´ˆ)']
];

function createInputs(container, prefix) {
  STAT_FIELDS.forEach(([key, label]) => {
    const row = document.createElement('label');
    row.innerHTML = `
      <span>${label}</span>
      <input type='number' id='${prefix}_${key}' value='0' step='0.01'>
    `;

    const input = row.querySelector('input');
    input.addEventListener('input', () => {
      if (['doubleproc', 'critproc'].includes(key)) {
        if (input.value > 100) input.value = 100;
      }
      if (input.value < 0) input.value = 0;
    });

    container.appendChild(row);
  });
}

createInputs(document.querySelector('.groupA'), 'a');
createInputs(document.querySelector('.groupB'), 'b');

document.getElementById('a_power').value = 100;
document.getElementById('a_hitrate').value = 1;
document.getElementById('a_vital').value = 1000;
document.getElementById('a_hpmult').value = 500;

document.getElementById('b_power').value = 100;
document.getElementById('b_hitrate').value = 1;
document.getElementById('b_vital').value = 1000;
document.getElementById('b_hpmult').value = 500;

/* -----------------------------------------------------------
   Skill selector: dynamic options and UI
----------------------------------------------------------- */
const SKILL_NAME = [
  'ì™¸ì¹¨', 'í™”ì‚´', 'ê³ ê¸°', 
  'ìˆ˜ë¦¬ê²€', 'í¬ê²©', 'ê´‘ì „ì‚¬',
  'ê°€ì‹œ', 'í™”ì‚´ë¹„', 'ë²„í”„',
  'ìš´ì„', 'í­íƒ„', 'ì‚¬ê¸°',
  'ì‡„ë„', 'ë²Œë ˆ', 'ë²ˆê°œ',
  'ê¸°ì´ì†Œì‚¬', 'ë“œë¡ ', 'ë†’ì€ ì‚¬ê¸°'
];

// ê´€ë¦¬ìê°€ íŠ¹ì • ìƒí™©ì—ì„œ ë“œë¡­ë‹¤ìš´ì—ì„œ ì„ íƒì„ ê¸ˆì§€í•˜ê³  ì‹¶ì€ ìŠ¤í‚¬ì„
// ì´ ë°°ì—´ì— ì¶”ê°€í•˜ë©´ í•´ë‹¹ ìŠ¤í‚¬ì€ ëª¨ë“  ì…€ë ‰íŠ¸ì—ì„œ ë¹„í™œì„±í™”ë©ë‹ˆë‹¤.
// ì˜ˆ: const IGNORE_SKILLS = ['ê³ ê¸°', 'ë“œë¡ '];
const IGNORE_SKILLS = ['ê³ ê¸°', 'ê´‘ì „ì‚¬', 'ë²„í”„', 'ì‚¬ê¸°', 'ë†’ì€ ì‚¬ê¸°'];

function createSelect(idPrefix) {
  const wrapper = document.createElement('div');
  wrapper.style.display = 'flex';
  wrapper.style.alignItems = 'center';

  const sel = document.createElement('select');
  sel.className = 'skill-select';
  sel.id = idPrefix;

  // ê¸°ë³¸ ë¹„ì„ íƒ ì˜µì…˜
  const empty = document.createElement('option');
  empty.value = '';
  empty.textContent = '--ì„ íƒ--';
  sel.appendChild(empty);

  SKILL_NAME.forEach(opt => {
    const o = document.createElement('option');
    o.value = opt;
    o.textContent = opt;
    // ë§Œì•½ IGNORE ëª©ë¡ì— ìˆìœ¼ë©´ ê¸°ë³¸ì ìœ¼ë¡œ ë¹„í™œì„±í™”
    if (IGNORE_SKILLS.includes(opt)) o.disabled = true;
    sel.appendChild(o);
  });

  const icon = document.createElement('div');
  icon.className = 'skill-icon';

  sel.addEventListener('change', () => {
    const container = sel.closest('.skill-column');
    if (container) updateExclusiveForContainer(container);
    updateSkillIconForSelect(sel);
  });

  wrapper.appendChild(sel);
  wrapper.appendChild(icon);
  return wrapper;
}

function updateExclusiveForContainer(container) {
  const selects = Array.from(container.querySelectorAll('select'));
  const chosen = selects.map(s => s.value).filter(v => v);

  selects.forEach(s => {
    Array.from(s.options).forEach(opt => {
      if (!opt.value) { // '--ì„ íƒ--'
        opt.disabled = false;
        return;
      }

      const isIgnored = IGNORE_SKILLS.includes(opt.value);

      // í˜„ì¬ selectì—ì„œ ì„ íƒí•œ ê°’ì€ ìœ ì§€(ì„ íƒ ê°€ëŠ¥ ìƒíƒœë¡œ ë³´ì´ë„ë¡),
      // ë‹¨, ê´€ë¦¬ìê°€ ì™„ì „íˆ ê¸ˆì§€í•˜ê¸¸ ì›í•˜ë©´ isIgnored ì²˜ë¦¬ë§Œìœ¼ë¡œë„ ë¨.
      if (s.value === opt.value) {
        // keep selected option enabled so it displays as selected
        opt.disabled = false;
      } else {
        // disabled if it's either chosen by another select or listed in IGNORE_SKILLS
        opt.disabled = isIgnored || chosen.includes(opt.value);
      }
    });
  });
}

function renderSkillSelectors() {
  const left = document.getElementById('mySkills');
  const right = document.getElementById('enemySkills');

  // clear any existing selects (but keep label)
  [...left.querySelectorAll('select')].forEach(n => n.remove());
  [...right.querySelectorAll('select')].forEach(n => n.remove());

  for (let i = 1; i <= 3; i++) {
    const sLwrap = createSelect('left_skill_' + i);
    left.appendChild(sLwrap);

    const sRwrap = createSelect('right_skill_' + i);
    right.appendChild(sRwrap);
  }

  // ì´ˆê¸° ìƒíƒœì—ì„œ ì¤‘ë³µ ì„ íƒ ë¶ˆê°€ ì ìš©
  updateExclusiveForContainer(left);
  updateExclusiveForContainer(right);
}

// ìŠ¤í”„ë¼ì´íŠ¸ í–‰ ì¸ë±ìŠ¤ëŠ” `SKILL_NAME` ë°°ì—´ì˜ ìˆœì„œ(index)ì™€ ì¼ì¹˜í•©ë‹ˆë‹¤.

function updateSkillIconForSelect(sel) {
  const wrapper = sel.parentElement;
  const icon = wrapper.querySelector('.skill-icon');
  if (!icon) return;

  const v = sel.value;
  if (!v || SKILL_NAME.indexOf(v) === -1) {
    icon.style.visibility = 'hidden';
    return;
  }

  const idx = SKILL_NAME.indexOf(v);
  const SLICE_H = 48;
  const SHEET_H = 864; // fixed full image height in pixels

  if (idx < 0 || idx * SLICE_H >= SHEET_H) {
    icon.style.visibility = 'hidden';
    return;
  }

  icon.style.backgroundSize = `48px ${SHEET_H}px`;
  const posY = -(idx * SLICE_H);
  icon.style.backgroundPosition = `0px ${posY}px`;
  icon.style.visibility = 'visible';
}

function updateAllSkillIcons(container) {
  const selects = container.querySelectorAll('select');
    selects.forEach(s => {
      updateSkillIconForSelect(s);
    });
}

// initial render
renderSkillSelectors();
  // ì´ˆê¸° ì•„ì´ì½˜ ìƒíƒœ ì—…ë°ì´íŠ¸
  const left = document.getElementById('mySkills');
  const right = document.getElementById('enemySkills');
  updateAllSkillIcons(left);
  updateAllSkillIcons(right);

/* -----------------------------------------------------------
   Helper
----------------------------------------------------------- */
function num(id) { return +document.getElementById(id).value; }

function pretty(n) {
  return Math.abs(n) >= 1e6
    ? (n / 1e6).toFixed(2) + 'M'
    : Math.abs(n) >= 1e3
    ? (n / 1e3).toFixed(2) + 'K'
    : n.toFixed(2);
}

/* -----------------------------------------------------------
   Core Combat Math (rewritten structure)
----------------------------------------------------------- */
function loadFighter(prefix) {
  const maxHP = num(prefix + '_vital') * (num(prefix + '_hpmult') / 100);

  return {
    power: num(prefix + '_power'),
    hits: num(prefix + '_hitrate'),
    attackSpeed: num(prefix + '_speedbuff') / 100,
    dbAttackRate: num(prefix + '_doubleproc') / 100,
    critRate: num(prefix + '_critproc') / 100,
    critDmg: 1.2 + (num(prefix + '_critbonus') / 100),
    drain: num(prefix + '_drain') / 100,
    regen: num(prefix + '_regen') / 100,
    block: num(prefix + '_guard') / 100,
    hp0: num(prefix + '_vital'),
    hpMax: maxHP,
    delay: num(prefix + '_startup')
  };
}

function getDamageByHit(user) {
  const critDamage = (user.power * user.critDmg * user.critRate) + (user.power * (1 - user.critRate));
  const dbDamegeRate = (2 * user.dbAttackRate) + (1 * (1 - user.dbAttackRate));
  const damage = critDamage * dbDamegeRate;
  return damage;
}

function battleSimulation(defender, attacker) {
  const damge = getDamageByHit(attacker) * (1 - defender.block);
  const drain = getDamageByHit(defender) * defender.drain;

  let hp = defender.hpMax;
  let t = 0;
  const dt = 1;

  const timeline = [];
  const hitBySec = parseFloat((1 / (attacker.hits * (1 + attacker.attackSpeed))).toFixed(1)) * 10;
  let hitTimer = hitBySec;

  const drainBySec = parseFloat((1 / (defender.hits * (1 + defender.attackSpeed))).toFixed(1)) * 10;
  let drainTimer = drainBySec;

  const healPerSec = hp * defender.regen;

  while (hp > 0 && t < 600) {
    // attackerì˜ íˆíŠ¸ íƒ€ì´ë°ì— ë§ì¶° ë°ë¯¸ì§€ ì ìš©
    if (t === hitTimer) {
      hp -= damge;
      hitTimer += hitBySec;
    }

    // ì²´ì  ì€ 0.1ì´ˆ ë‹¨ìœ„ë¡œ ê³„ì‚°
    let heal = (defender.hp0 * defender.regen)/10;

    // defenderì˜ ë“œë ˆì¸ íƒ€ì´ë°ì— ë§ì¶° í¡í˜ˆ ì ìš©
    if (t === drainTimer) {
      heal += drain;
      drainTimer += drainBySec;
    }

    hp += heal;

    timeline.push([(t/10).toFixed(1), hp]);

    t += dt;
  }

  return { time: hp > 0 ? Infinity : ((t-1)/10), log: timeline, hp };
}

/* -----------------------------------------------------------
   Simulation Runner
----------------------------------------------------------- */
function startBattle() {
  const A = loadFighter('a');
  const B = loadFighter('b');

  const A_TTD = battleSimulation(A, B);
  const B_TTD = battleSimulation(B, A);

  const out = document.getElementById('battleResult');

  let msg = `
    ë‚´ê°€ ì“°ëŸ¬ì§„ ì‹œê°„: ${A_TTD.time.toFixed(1)}s<br>
    ì ì´ ì“°ëŸ¬ì§„ ì‹œê°„: ${B_TTD.time.toFixed(1)}s<br><br>
  `;

  if (A_TTD.time === Infinity && B_TTD.time === Infinity) {
    msg = `
        ë‚˜ì˜ ë‚¨ì€ ì²´ë ¥: ${pretty(A_TTD.hp)}<br>
        ì ì˜ ë‚¨ì€ ì²´ë ¥: ${pretty(B_TTD.hp)}<br><br>
    `;

    if (A_TTD.hp > B_TTD.hp)
      msg += 'ğŸ¥‡ ìŠ¹ë¦¬';
    else if (B_TTD.hp > A_TTD.hp)
      msg += 'â˜ ï¸ íŒ¨ë°°';
    else
    msg += 'ğŸ¤ ë¬´ìŠ¹ë¶€';
  } else if (A_TTD.time > B_TTD.time)
    msg += 'ğŸ¥‡ ìŠ¹ë¦¬';
  else if (B_TTD.time > A_TTD.time)
    msg += 'â˜ ï¸ íŒ¨ë°°';
  else
    msg += 'ğŸ¤ ë¬´ìŠ¹ë¶€';

  out.innerHTML = msg;

  logTimeline(A_TTD.log, B_TTD.log, A.delay, B.delay);
}

/* -----------------------------------------------------------
   Debug timeline table
----------------------------------------------------------- */
function logTimeline(logA, logB, delayA, delayB) {
  const tb = document.querySelector('#logTable tbody');
  tb.innerHTML = '';

  const len = Math.max(logA.length, logB.length);

  for (let i = 0; i < len; i++) {
    const a = logA[i] || [];
    const b = logB[i] || [];
    const t = a[0] || b[0];

    const row = document.createElement('tr');

    const isAStart = +t === +delayA;
    const isBStart = +t === +delayB;

    if (a[1] <= 0) a[1] = 0;
    if (b[1] <= 0) b[1] = 0;

    row.innerHTML = `
      <td>${t}</td>
      <td class='${isAStart ? 'highlight' : ''}'>${a[1] ? pretty(+a[1]) : 'â˜ ï¸'}</td>
      <td class='${isBStart ? 'highlight' : ''}'>${b[1] ? pretty(+b[1]) : 'â˜ ï¸'}</td>
    `;

    tb.appendChild(row);
  }
}

</script>

</body>
</html>
